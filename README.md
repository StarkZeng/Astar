# Astar
#各种版本的 Atar算法实现
按照 http://www.cppblog.com/mythit/archive/2009/04/19/80492.aspx 描述实现的具体代码
流程:
   1，把起始格添加到开启列表。
   2，重复如下的工作：
      a) 寻找开启列表中F值最低的格子。我们称它为当前格。
      b) 把它切换到关闭列表。
      c) 对相邻的格中的每一个？
          * 如果它不可通过或者已经在关闭列表中，略过它。反之如下。
          * 如果它不在开启列表中，把它添加进去。把当前格作为这一格的父节点。记录这一格的F,G,和H值。
          * 如果它已经在开启列表中，用G值为参考检查新的路径是否更好。更低的G值意味着更好的路径。如果是这样，就把这一格的父节点改成当前格，并且重新计算这一格的G和F值。如果你保持你的开启列表按F值排序，改变之后你可能需要重新对开启列表排序。
      d) 停止，当你
          * 把目标格添加进了关闭列表(注解)，这时候路径被找到，或者
          * 没有找到目标格，开启列表已经空了。这时候，路径不存在。
   3.保存路径。从目标格开始，沿着每一格的父节点移动直到回到起始格。这就是你的路径。

1.lua 版本
可以直接运行看结果
以下地方需要改进:
1).为了提高效率 周围8个方向的个子都使用1作为距离计算,其实斜向的个子应该用√2 ,这里需要改进下
2).目前这个算法 的性能热点：节点插入openlist的时候每次需要排序 但是lua中的排序算法是快排 因为是对有序队列的排序 自己实现其他的排序算法应该更快

2.C 版本
纯C版本 不依赖第三方代码 自己实现了个双向链表模拟lua里面的简单的table
可以直接运行看结果
step 1: gcc Astar.c -o Astar
step 2: ./Astar

因为C的高效率 计算距离使用了sqrt ,斜向格子也用1.4的距离
但是路径还是没有平滑,具体做法再学习下
由于写的比较快 没有实现的地方是:(都已实现了!)
1)没实现链表的快速插入排序 只是简单的处理为先移除出node 再将node加回去(加回去的时候函数会自己动排序)
2)所有节点的分配只有malloc 没有free 直接使用会内存泄露 ,由于后续会加上 pool,这个问题暂时不管 ,pool类似于Lua里面写得那种实现 后面来做




   

